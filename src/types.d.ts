// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
}
interface FileAPI {
  openFile: () => Promise<{ fileName: string; content: string } | null>;
  saveFile: (fileName: string, content: string) => Promise<boolean>;
}

interface FFmpegProgress {
  frame: number;
  fps: number;
  time: string;
  bitrate: string;
  speed: string;
  percentage: number;
  eta: string | null;
}

type LogType = "info" | "success" | "warning" | "error" | "debug" | "metadata";

interface FFmpegStartParams {
  videoPath: string;
  subtitlePath: string;
  outputPath: string;
  settings?: {
    bitrate: string;
    useHardwareAccel: boolean;
  };
}

interface FFmpegDownloadProgress {
  downloadedBytes: number;
  totalBytes: number;
  percentage: number;
  status: "downloading" | "extracting" | "complete" | "error";
  message?: string;
}

interface QueueItem {
  id: string;
  videoPath: string;
  videoName: string;
  subtitlePath: string;
  subtitleName: string;
  outputPath: string;
  status: "pending" | "processing" | "completed" | "error" | "cancelled";
  progress: FFmpegProgress | null;
  error?: string;
  logs: Array<{ log: string; type: LogType }>;
}

interface QueueStats {
  total: number;
  pending: number;
  processing: number;
  completed: number;
  error: number;
  cancelled: number;
}

interface FFmpegAPI {
  selectVideoFile: () => Promise<{ filePath: string; fileName: string } | null>;
  selectSubtitleFile: () => Promise<{ filePath: string; fileName: string } | null>;
  selectOutputPath: (defaultName: string) => Promise<string | null>;
  startProcess: (params: FFmpegStartParams) => Promise<{ success: boolean }>;
  cancelProcess: () => Promise<{ success: boolean; message?: string }>;
  checkGpu: () => Promise<{ available: boolean; info: string }>;
  openOutputFolder: (filePath: string) => Promise<{ success: boolean; error?: string }>;
  onProgress: (callback: (progress: FFmpegProgress) => void) => () => void;
  onLog: (callback: (data: { log: string; type: LogType }) => void) => () => void;
  onComplete: (callback: (outputPath: string) => void) => () => void;
  onError: (callback: (error: string) => void) => () => void;
  // FFmpeg Download
  checkInstalled: () => Promise<{ installed: boolean }>;
  startDownload: () => Promise<{ success: boolean }>;
  onDownloadProgress: (callback: (progress: FFmpegDownloadProgress) => void) => () => void;
  onDownloadComplete: (callback: () => void) => () => void;
  onDownloadError: (callback: (error: string) => void) => () => void;
  // Queue Management
  queueAddItem: (item: Omit<QueueItem, "id" | "status" | "progress" | "logs">) => Promise<{ success: boolean; id: string }>;
  queueAddItems: (items: Array<Omit<QueueItem, "id" | "status" | "progress" | "logs">>) => Promise<{ success: boolean; ids: string[] }>;
  queueRemoveItem: (id: string) => Promise<{ success: boolean; message?: string }>;
  queueClear: () => Promise<{ success: boolean; message?: string }>;
  queueReorder: (fromIndex: number, toIndex: number) => Promise<{ success: boolean; message?: string }>;
  queueStart: () => Promise<{ success: boolean; message?: string }>;
  queuePause: () => Promise<{ success: boolean; message?: string }>;
  queueResume: () => Promise<{ success: boolean; message?: string }>;
  queueGetAll: () => Promise<{ queue: QueueItem[] }>;
  queueGetStats: () => Promise<QueueStats>;
  queueUpdateSettings: (settings: { bitrate: string; useHardwareAccel: boolean }) => Promise<{ success: boolean }>;
  queueSelectFiles: () => Promise<{ success: boolean; files: Array<{ filePath: string; fileName: string }> }>;
  // Queue Event Listeners
  onQueueUpdate: (callback: (queue: QueueItem[]) => void) => () => void;
  onQueueItemUpdate: (callback: (item: QueueItem) => void) => () => void;
  onQueueItemProgress: (callback: (data: { itemId: string; progress: FFmpegProgress }) => void) => () => void;
  onQueueItemLog: (callback: (data: { itemId: string; log: string; type: LogType }) => void) => () => void;
  onQueueItemComplete: (callback: (data: { itemId: string; outputPath: string }) => void) => () => void;
  onQueueItemError: (callback: (data: { itemId: string; error: string }) => void) => () => void;
  onQueueComplete: (callback: () => void) => () => void;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  fileAPI: FileAPI;
  ffmpegAPI: FFmpegAPI;
}
